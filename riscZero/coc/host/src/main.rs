// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    COC_GUEST_ELF, COC_GUEST_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};

use std::env;

#[macro_use] extern crate rocket;

#[derive(serde::Serialize, serde::Deserialize)]
struct Params {
    troops: Vec<GameEntity>,
    cannons: Vec<GameEntity>,
    townhall: GameEntity,
}

#[derive(serde::Serialize, serde::Deserialize)]
struct GameEntity {
    name: String,
    health: i32,
    attack: i32,
    position: (i32, i32),
    fire_rate: i64, // Time b/w two attacks in s
}

#[get("/attack")]
fn attack() -> Vec<u8> {
  let troops = vec![
        GameEntity {
            name: "Charizard1".to_string(),
            health: 1000,
            attack: 200,
            position: (120, 420),
            fire_rate: 4, 
        },
        GameEntity {
            name: "Charizard2".to_string(),
            health: 1000,
            attack: 200,
            position: (870, 440),
            fire_rate: 4,
        },
    ];

    let cannons = vec![
        GameEntity {
            name: "Cannon1".to_string(),
            health: 1200,
            attack: 100,
            position: (350, 340),
            fire_rate: 3,
        },
        GameEntity {
            name: "Cannon2".to_string(),
            health: 1200,
            attack: 100,
            position: (680, 380),
            fire_rate: 3,
        },
    ];

    let townhall = GameEntity {
        name: "Base".to_string(),
        health: 2400,
        attack: 0,
        position: (530, 300),
        fire_rate: 0,
    };
    
    let total_buildings = cannons.len() + 1;

    let params = Params {
        troops,
        cannons,
        townhall
    };

    let env = ExecutorEnv::builder()
    .write_slice(&bincode::serialize(&params).unwrap())
    .build().unwrap();

    // Obtain the default prover.
    let prover = default_prover();
    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove(env, COC_GUEST_ELF).unwrap();
    // Deserialize result
    let result: i32 = receipt.journal.decode().unwrap();
    assert_eq!(result, total_buildings as i32, "Incorrect attack output!");
    // Verify the receipt
    receipt.verify(COC_GUEST_ID).unwrap();

  let serialized_receipt = serde_json::to_vec(&receipt).unwrap();
  serialized_receipt
}

// --- Rocket server
use rocket::http::Header;
use rocket::{Request, Response};
use rocket::fairing::{Fairing, Info, Kind};

pub struct CORS;

#[rocket::async_trait]
impl Fairing for CORS {
    fn info(&self) -> Info {
        Info {
            name: "Attaching CORS headers to responses",
            kind: Kind::Response
        }
    }

    async fn on_response<'r>(&self, request: &'r Request<'_>, response: &mut Response<'r>) {
        response.set_header(Header::new("Access-Control-Allow-Origin", "*"));
        response.set_header(Header::new("Access-Control-Allow-Methods", "POST, GET, PATCH, OPTIONS"));
        response.set_header(Header::new("Access-Control-Allow-Headers", "*"));
        response.set_header(Header::new("Access-Control-Allow-Credentials", "true"));

        // Handle preflight requests
        if request.method() == rocket::http::Method::Options {
          response.set_status(rocket::http::Status::NoContent);
        }
    }
}

#[launch]
fn rocket() -> _ {
  rocket::build().attach(CORS).mount("/", routes![attack])
}